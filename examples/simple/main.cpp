#include "server_impl.h"
#include "xll_definitions.h"
#include <vector>
#include <cstdarg>
#include <cwchar>

// 3. Define Entry Points
RTD_DEFINE_DLL_ENTRY(MyRtdServer, CLSID_MyRtdServer, g_szProgID, g_szFriendlyName)

// Forward declare DllRegisterServer (generated by macro)
extern "C" HRESULT __stdcall DllRegisterServer();

// --- XLL Implementation ---

// Helper to call Excel12
static int Excel12v(int xlfn, LPXLOPER12 pxResult, int count, LPXLOPER12 opers[]) {
    static PEXCEL12 pExcel12 = nullptr;
    if (!pExcel12) {
        HMODULE hMod = GetModuleHandleA("xlcall32.dll");
        if (!hMod) hMod = LoadLibraryA("xlcall32.dll");
        if (hMod) pExcel12 = (PEXCEL12)GetProcAddress(hMod, "Excel12");
    }
    if (!pExcel12) return -1; // xlretFailed
    return pExcel12(xlfn, count, pxResult, opers);
}

// Variadic wrapper
static int Excel12(int xlfn, LPXLOPER12 pxResult, int count, ...) {
    std::vector<LPXLOPER12> opers(count);
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; ++i) {
        opers[i] = va_arg(args, LPXLOPER12);
    }
    va_end(args);
    return Excel12v(xlfn, pxResult, count, opers.data());
}

// Helper to create XLOPER12 string
static void SetXlString(XLOPER12& xOp, const wchar_t* str) {
    xOp.xltype = xltypeStr;
    size_t len = wcslen(str);
    if (len > 32767) len = 32767;

    // Allocate buffer with length prefix
    XCHAR* buf = new XCHAR[len + 1];
    buf[0] = (XCHAR)len;
    if (len > 0) wmemcpy(buf + 1, str, len);

    xOp.val.str = buf;
}

// Simple test function
extern "C" __declspec(dllexport) LPXLOPER12 WINAPI MyHello() {
    static XLOPER12 xResult;
    // "Hello from XLL" (Length 14)
    static XCHAR buf[] = L"\x000EHello from XLL";
    xResult.xltype = xltypeStr;
    xResult.val.str = buf;
    return &xResult;
}

// 4. XLL Entry Point
extern "C" __declspec(dllexport) void WINAPI xlAutoOpen() {
    // 1. Self-Register the COM Server (Hybrid feature)
    // This ensures the RTD server is registered for the current user when the XLL is opened.
    HRESULT hr = DllRegisterServer();
    if (FAILED(hr)) {
        OutputDebugStringW(L"MyHybridServer: DllRegisterServer failed in xlAutoOpen\n");
    } else {
        OutputDebugStringW(L"MyHybridServer: DllRegisterServer succeeded in xlAutoOpen\n");
    }

    // 2. Register XLL functions
    static XLOPER12 xDLL, xFunc, xType, xName;

    // Get DLL name
    Excel12(xlfGetName, &xDLL, 0);

    // Prepare Registration Arguments for MyHello
    SetXlString(xFunc, L"MyHello"); // Export name
    SetXlString(xType, L"Q");       // Signature (Returns LPXLOPER12, no args)
    SetXlString(xName, L"MyHello"); // Excel Function Name

    // Register
    XLOPER12 xRes;
    Excel12(xlfRegister, &xRes, 4,
        &xDLL,
        &xFunc,
        &xType,
        &xName
    );

    // Cleanup memory allocated by SetXlString
    delete[] xFunc.val.str;
    delete[] xType.val.str;
    delete[] xName.val.str;

    // Free the DLL name returned by xlfGetName
    Excel12(xlFree, 0, 1, &xDLL);
}

extern "C" __declspec(dllexport) void WINAPI xlAutoClose() {
    // Cleanup if needed
    OutputDebugStringW(L"MyHybridServer: xlAutoClose called\n");
}
